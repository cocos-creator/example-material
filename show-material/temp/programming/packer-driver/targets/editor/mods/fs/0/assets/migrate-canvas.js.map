{"version":3,"sources":["file:///D:/material-examples/show-material/assets/migrate-canvas.ts"],"names":["setChildrenLayer","node","layer","i","l","children","length","getCanvasCameraLayer","canvas","getComponent","Canvas","cameraComponent","visibility","parent","Node","director","Director","game","Camera","EDITOR","customLayerMask","builtinLayerMask","on","EVENT_AFTER_SCENE_LAUNCH","roots","getScene","allCanvases","getComponentsInChildren","filter","x","allCameras","usedLayer","forEach","persistCanvas","root","isPersistRootNode","canvases","push","val","isLayerCollided","find","availableLayers","lastAvailableLayer","setParentEngine","prototype","setParent","value","keepWorldTransform","call"],"mappings":"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","sourcesContent":["/**\r\n * UI 的渲染在 v3.0 变为使用 node.layer 来判断可见性，为了保证老版本项目升级后表现一致，\r\n * Creator 会在运行时动态分配一个未使用的 layer 给常驻节点的 UI，避免常驻节点的 UI 与场景中\r\n * 的其他 UI 的 layer 发生冲突，当你确定不会发生冲突时，你可以移除此脚本.\r\n * \r\n * UI rendering has changed in v3.0 to use node.layer to determine visibility. \r\n * To ensure consistent performance after upgrading old projects. \r\n * Creator will dynamically assign an unused layer to the UI node in the persist node at \r\n * runtime to avoid conflicts between the layer of UI in the persist node and the \r\n * layer of other UI in the scene. You can remove this script when you \r\n * are sure there is no conflict\r\n */\r\n\r\nimport { _decorator, Node, director, Director, game, BaseNode, Canvas, Camera } from 'cc';\r\nimport { EDITOR } from 'cc/env';\r\n\r\nconst customLayerMask = 0x000fffff;\r\nconst builtinLayerMask = 0xfff00000;\r\n\r\ndirector.on(Director.EVENT_AFTER_SCENE_LAUNCH, () => {\r\n    const roots = director.getScene()?.children as BaseNode[];\r\n    let allCanvases = director.getScene()?.getComponentsInChildren(Canvas) as Canvas[];\r\n    if (allCanvases.length <= 1) return;\r\n    allCanvases = allCanvases.filter(x => !!x.cameraComponent);\r\n    \r\n    let allCameras = director.getScene()?.getComponentsInChildren(Camera) as Camera[];\r\n    let usedLayer = 0;\r\n    allCameras.forEach(x => usedLayer |= (x.visibility & customLayerMask));\r\n\r\n    const persistCanvas: Canvas[] = [];\r\n    for (let i = 0, l = roots.length; i < l; i++) {\r\n        const root = roots[i];\r\n        if (!game.isPersistRootNode(root)) continue;\r\n        const canvases = root.getComponentsInChildren(Canvas);\r\n        if (canvases.length === 0) continue;\r\n        persistCanvas.push(...canvases.filter(x => !!x.cameraComponent));\r\n    }\r\n\r\n    persistCanvas.forEach((val) => {\r\n        const isLayerCollided = allCanvases.find(x => x !== val && (x.cameraComponent!.visibility & val.cameraComponent!.visibility & customLayerMask));\r\n        if (isLayerCollided) {\r\n            const availableLayers = ~usedLayer;\r\n            const lastAvailableLayer = availableLayers & ~(availableLayers - 1);\r\n            val.cameraComponent!.visibility = lastAvailableLayer | (val.cameraComponent!.visibility & builtinLayerMask);\r\n            setChildrenLayer(val.node, lastAvailableLayer);\r\n            usedLayer |= availableLayers;\r\n        }\r\n    });\r\n});\r\n\r\nfunction setChildrenLayer (node: Node, layer: number) {\r\n    for (let i = 0, l = node.children.length; i < l; i++) {\r\n        node.children[i].layer = layer;\r\n        setChildrenLayer(node.children[i], layer);\r\n    }\r\n}\r\n\r\nlet setParentEngine = Node.prototype.setParent;\r\n\r\nif(!EDITOR) {\r\n    Node.prototype.setParent = function(value, keepWorldTransform) {\r\n        setParentEngine.call(this, value, keepWorldTransform);\r\n        if (!value) return;\r\n        // find canvas\r\n        let layer = getCanvasCameraLayer(this);\r\n        if (layer) {\r\n            this.layer = layer;\r\n            setChildrenLayer(this, layer);\r\n        }\r\n    }\r\n}\r\n\r\nfunction getCanvasCameraLayer (node: Node) {\r\n    let layer = 0;\r\n    let canvas = node.getComponent(Canvas);\r\n    if (canvas && canvas.cameraComponent) {\r\n        if (canvas.cameraComponent.visibility & canvas.node.layer) {\r\n            layer = canvas.node.layer;\r\n        } else {\r\n            layer = canvas.cameraComponent.visibility & ~(canvas.cameraComponent.visibility - 1);\r\n        }\r\n        return layer;\r\n    }\r\n    if (node.parent) {\r\n        layer = getCanvasCameraLayer(node.parent);\r\n    }\r\n    return layer;\r\n}"]}